/**
 * ==============================================================================
 * NETKNIFE - CVE & VULNERABILITY LOOKUP LAMBDA
 * ==============================================================================
 *
 * Fetches CVE data from NVD (NIST) and OSV; optional AI "should I be worried?"
 * analysis. Uses FREE APIs: NVD 2.0, OSV (no keys required; NVD_API_KEY optional
 * for higher rate limits).
 *
 * MODES:
 * - cve:     { cveId: "CVE-2024-1234", analyze?: boolean }
 * - package: { ecosystem: "npm", package: "lodash", version: "4.17.21", analyze?: boolean }
 *
 * METERING: fetch = remote; AI analysis = advisor.
 * ==============================================================================
 */

const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, GetCommand, PutCommand } = require("@aws-sdk/lib-dynamodb");
const { getAuth, checkLimit, incrementUsage } = require("netknife-billing");

const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}));
const CACHE_TABLE = process.env.CACHE_TABLE;
const NVD_API_KEY = process.env.NVD_API_KEY || "";
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";

// ------------------------------------------------------------------------------
// HELPERS
// ------------------------------------------------------------------------------

function json(status, body) {
  return { statusCode: status, headers: { "Content-Type": "application/json", "Cache-Control": "no-store" }, body: JSON.stringify(body) };
}

async function cacheGet(key) {
  if (!CACHE_TABLE) return null;
  try {
    const r = await ddb.send(new GetCommand({ TableName: CACHE_TABLE, Key: { cache_key: key } }));
    if (r.Item && r.Item.expires_at > Math.floor(Date.now() / 1000)) return r.Item.value;
  } catch (e) { console.warn("CVE cache get:", e.message); }
  return null;
}

async function cachePut(key, value, ttlSec) {
  if (!CACHE_TABLE) return;
  try {
    await ddb.send(new PutCommand({
      TableName: CACHE_TABLE,
      Item: { cache_key: key, value, expires_at: Math.floor(Date.now() / 1000) + ttlSec },
    }));
  } catch (e) { console.warn("CVE cache put:", e.message); }
}

// ------------------------------------------------------------------------------
// NVD 2.0
// ------------------------------------------------------------------------------

async function fetchNvd(cveId) {
  const norm = String(cveId || "").trim().toUpperCase();
  if (!/^CVE-\d{4}-\d{4,}$/.test(norm)) return null;
  const url = new URL("https://services.nvd.nist.gov/rest/json/cves/2.0");
  url.searchParams.set("cveId", norm);
  if (NVD_API_KEY) url.searchParams.set("apiKey", NVD_API_KEY);

  const res = await fetch(url.toString(), { headers: { Accept: "application/json" } });
  if (!res.ok) return null;
  const data = await res.json();
  const vulns = data?.vulnerabilities || [];
  const cve = vulns[0]?.cve;
  if (!cve) return null;

  const meta = cve.cveMetadata || {};
  const enDesc = (cve.descriptions || []).find((d) => (d.lang || "").toLowerCase() === "en");
  const desc = enDesc?.value || (cve.descriptions || [])[0]?.value || "";

  const metrics = cve.metrics || {};
  const cvss31 = (metrics.cvssMetricV31 || [])[0]?.cvssData;
  const cvss30 = (metrics.cvssMetricV30 || [])[0]?.cvssData;
  const cvss2 = (metrics.cvssMetricV2 || [])[0]?.cvssData;

  return {
    id: meta.cveId || norm,
    description: desc,
    published: meta.datePublished || null,
    updated: meta.dateUpdated || meta.datePublished || null,
    references: (cve.references || []).map((r) => r.url).filter(Boolean),
    cvss: {
      v3_1: cvss31 ? { score: cvss31.baseScore, severity: cvss31.baseSeverity, vector: cvss31.vectorString } : null,
      v3_0: cvss30 ? { score: cvss30.baseScore, severity: cvss30.baseSeverity, vector: cvss30.vectorString } : null,
      v2: cvss2 ? { score: cvss2.baseScore, severity: cvss2.baseSeverity, vector: cvss2.vectorString } : null,
    },
    cwe: (cve.weaknesses || [])[0]?.description?.[0]?.value || null,
    configurations: (cve.configurations || []).length,
  };
}

// ------------------------------------------------------------------------------
// OSV
// ------------------------------------------------------------------------------

async function fetchOsvByCve(cveId) {
  const norm = String(cveId || "").trim();
  if (!norm) return null;
  try {
    const res = await fetch(`https://api.osv.dev/v1/vulns/${encodeURIComponent(norm)}`, {
      headers: { Accept: "application/json" },
    });
    if (!res.ok) return null;
    const v = await res.json();
    return {
      id: v.id || null,
      summary: v.summary || v.details || null,
      affected: (v.affected || []).map((a) => ({ package: a.package?.name, ecosystem: a.package?.ecosystem, ranges: (a.ranges || []).length })),
      references: (v.references || []).map((r) => r.url).filter(Boolean),
      severity: (v.severity || []).map((s) => ({ type: s.type, score: s.score })).filter((s) => s.score),
    };
  } catch (e) { return null; }
}

async function fetchOsvByPackage(ecosystem, pkg, version) {
  if (!ecosystem || !pkg) return null;
  const body = { package: { name: String(pkg).trim(), ecosystem: String(ecosystem).trim() } };
  if (version) body.version = String(version).trim();
  try {
    const res = await fetch("https://api.osv.dev/v1/query", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) return null;
    const data = await res.json();
    const vulns = data?.vulns || [];
    return vulns.slice(0, 20).map((v) => ({
      id: v.id,
      summary: (v.summary || v.details || "").slice(0, 500),
      aliases: v.aliases || [],
      severity: (v.severity || []).map((s) => ({ type: s.type, score: s.score })).filter((s) => s.score),
    }));
  } catch (e) { return null; }
}

// ------------------------------------------------------------------------------
// AI ANALYSIS (OpenAI)
// ------------------------------------------------------------------------------

const CVE_AI_PROMPT = `You are a senior vulnerability analyst. Given CVE/vulnerability data, produce a SHORT "should I be worried?" assessment.

Respond ONLY with valid JSON in this shape:
{
  "verdict": "high" | "medium" | "low" | "informational",
  "one_liner": "Single sentence: should they be worried?",
  "factors": ["factor 1", "factor 2"],
  "recommendation": "1-2 sentences on what to do (patch, mitigate, monitor, or ignore)."
}

Be concise. Prefer "high" for Critical/High CVSS or RCE, default-insecure, or actively exploited. "low" for older, non-default, or requiring physical/local access.`;

async function aiAnalyzeCve(cveId, nvd, osv, pkgContext) {
  if (!OPENAI_API_KEY) return null;
  const ctx = [
    nvd ? `NVD: ${nvd.description?.slice(0, 800) || "No description"}. CVSS: ${JSON.stringify(nvd.cvss || {})}.` : "",
    osv ? `OSV: ${osv.summary?.slice(0, 400) || "No summary"}. Affected: ${JSON.stringify(osv.affected || [])}.` : "",
    pkgContext ? `User context: ${pkgContext}` : "",
  ].filter(Boolean).join("\n");

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: OPENAI_MODEL,
      messages: [
        { role: "system", content: CVE_AI_PROMPT },
        { role: "user", content: `CVE: ${cveId}\n\n${ctx || "No NVD/OSV data."}` },
      ],
      temperature: 0.3,
      max_tokens: 600,
      response_format: { type: "json_object" },
    }),
  });
  if (!res.ok) return null;
  const data = await res.json();
  const text = data?.choices?.[0]?.message?.content;
  if (!text) return null;
  try { return JSON.parse(text); } catch { return { one_liner: text, verdict: "unknown", factors: [], recommendation: "" }; }
}

// ------------------------------------------------------------------------------
// HANDLER
// ------------------------------------------------------------------------------

exports.handler = async (event) => {
  try {
    const { userId, username } = getAuth(event);
    if (userId === "unknown") return json(401, { error: "Authentication required" });

    const body = (event.body && typeof event.body === "string") ? JSON.parse(event.body) : (event.body || {});
    const mode = String(body.mode || "cve").toLowerCase();
    const analyze = !!body.analyze;

    // --- Remote: check and consume for the fetch ---
    const r = await checkLimit(userId, username, "remote", {
      billingTable: process.env.BILLING_TABLE,
      usageTable: process.env.USAGE_TABLE,
    });
    if (!r.allowed) return json(402, { code: r.code, upgradeUrl: r.upgradeUrl, message: r.message });

    if (mode === "cve") {
      const cveId = String(body.cveId || "").trim();
      if (!cveId) return json(400, { error: "cveId is required for mode cve" });

      const cacheKey = `cve:${cveId}:${analyze ? "1" : "0"}`;
      const cached = await cacheGet(cacheKey);
      if (cached) {
        await incrementUsage(userId, "remote", { usageTable: process.env.USAGE_TABLE });
        if (analyze && cached.ai_analysis) await incrementUsage(userId, "advisor", { usageTable: process.env.USAGE_TABLE });
        return json(200, { ...cached, cached: true });
      }

      const [nvd, osv] = await Promise.all([fetchNvd(cveId), fetchOsvByCve(cveId)]);
      if (!nvd && !osv) return json(404, { error: "CVE not found in NVD or OSV", cveId });

      let ai_analysis = null;
      if (analyze) {
        const ar = await checkLimit(userId, username, "advisor", {
          billingTable: process.env.BILLING_TABLE,
          usageTable: process.env.USAGE_TABLE,
        });
        if (!ar.allowed) {
          const out = { mode: "cve", cveId, nvd, osv, ai_analysis: null, analyze_limited: true, upgradeUrl: ar.upgradeUrl, message: ar.message };
          await incrementUsage(userId, "remote", { usageTable: process.env.USAGE_TABLE });
          return json(200, out);
        }
        const aiKey = `cve:ai:${cveId}`;
        ai_analysis = await cacheGet(aiKey);
        if (!ai_analysis) {
          ai_analysis = await aiAnalyzeCve(cveId, nvd, osv, body.context || null);
          if (ai_analysis) await cachePut(aiKey, ai_analysis, 86400);
          await incrementUsage(userId, "advisor", { usageTable: process.env.USAGE_TABLE });
        }
      }

      const result = { mode: "cve", cveId, nvd, osv, ai_analysis };
      await cachePut(cacheKey, result, 3600); // 1h for CVE data
      await incrementUsage(userId, "remote", { usageTable: process.env.USAGE_TABLE });
      return json(200, { ...result, cached: false });
    }

    if (mode === "package") {
      const ecosystem = String(body.ecosystem || "").trim();
      const pkg = String(body.package || "").trim();
      const version = (body.version && String(body.version).trim()) || null;
      if (!ecosystem || !pkg) return json(400, { error: "ecosystem and package are required for mode package" });

      const cacheKey = `cve:pkg:${ecosystem}:${pkg}:${version || ""}:${analyze ? "1" : "0"}`;
      const cached = await cacheGet(cacheKey);
      if (cached) {
        await incrementUsage(userId, "remote", { usageTable: process.env.USAGE_TABLE });
        if (analyze && cached.ai_analysis) await incrementUsage(userId, "advisor", { usageTable: process.env.USAGE_TABLE });
        return json(200, { ...cached, cached: true });
      }

      const osv = await fetchOsvByPackage(ecosystem, pkg, version);
      const vulns = Array.isArray(osv) ? osv : (osv ? [osv] : []);
      const firstCve = vulns[0]?.id || vulns[0]?.aliases?.[0];
      let nvd = null;
      if (firstCve && /^CVE-/.test(firstCve)) nvd = await fetchNvd(firstCve);

      let ai_analysis = null;
      if (analyze && (vulns.length > 0 || nvd)) {
        const ar = await checkLimit(userId, username, "advisor", {
          billingTable: process.env.BILLING_TABLE,
          usageTable: process.env.USAGE_TABLE,
        });
        if (!ar.allowed) {
          const out = { mode: "package", ecosystem, package: pkg, version, vulns, nvd: nvd ? [nvd] : [], ai_analysis: null, analyze_limited: true, upgradeUrl: ar.upgradeUrl, message: ar.message };
          await incrementUsage(userId, "remote", { usageTable: process.env.USAGE_TABLE });
          return json(200, out);
        }
        const ctx = `${ecosystem}/${pkg}${version ? "@" + version : ""}`;
        ai_analysis = await aiAnalyzeCve(firstCve || pkg, nvd, vulns[0] || null, ctx);
        await incrementUsage(userId, "advisor", { usageTable: process.env.USAGE_TABLE });
      }

      const result = { mode: "package", ecosystem, package: pkg, version, vulns, nvd: nvd ? [nvd] : [], ai_analysis };
      await cachePut(cacheKey, result, 1800);
      await incrementUsage(userId, "remote", { usageTable: process.env.USAGE_TABLE });
      return json(200, { ...result, cached: false });
    }

    return json(400, { error: "mode must be 'cve' or 'package'" });
  } catch (e) {
    console.error("CVE lookup error:", e);
    return json(500, { error: e.message || "CVE lookup failed" });
  }
};

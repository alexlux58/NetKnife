/**
 * ==============================================================================
 * NETKNIFE - CVE & VULNERABILITY LOOKUP LAMBDA
 * ==============================================================================
 *
 * Fetches CVE data from NVD (NIST) and OSV; optional AI "should I be worried?"
 * analysis. Uses FREE APIs: NVD 2.0, OSV (no keys required; NVD_API_KEY optional
 * for higher rate limits).
 *
 * MODES:
 * - cve:     { cveId: "CVE-2024-1234", analyze?: boolean }
 * - package: { ecosystem: "npm", package: "lodash", version: "4.17.21", analyze?: boolean }
 * - top:     { period: "this_month"|"last_month"|"last_90", severity: "CRITICAL"|"HIGH"|"BOTH", category?: string }
 *            -> top 30 CVEs by period/category/severity (NVD search)
 * ==============================================================================
 */

const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, GetCommand, PutCommand } = require("@aws-sdk/lib-dynamodb");

const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}));
const CACHE_TABLE = process.env.CACHE_TABLE;
const NVD_API_KEY = process.env.NVD_API_KEY || "";
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";

const NVD_RATE_DELAY_MS = NVD_API_KEY ? 200 : 6500; // 5/30s without key -> ~6.5s between calls
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

// category (frontend value) -> NVD keywordSearch
const CATEGORY_KEYWORDS = {
  all: null,
  microsoft: "Microsoft",
  apache: "Apache",
  "linux kernel": "Linux kernel",
  cisco: "Cisco",
  vmware: "VMware",
  rce: "remote code execution",
  auth: "authentication",
  wordpress: "WordPress",
  kubernetes: "Kubernetes",
  oracle: "Oracle",
  adobe: "Adobe",
  fortinet: "Fortinet",
  sap: "SAP",
  google: "Google",
  apple: "Apple",
  php: "PHP",
  jenkins: "Jenkins",
  drupal: "Drupal",
};

// ------------------------------------------------------------------------------
// HELPERS
// ------------------------------------------------------------------------------

function getAuth(event) {
  const claims = event.requestContext?.authorizer?.jwt?.claims || event.requestContext?.authorizer?.claims || {};
  const sub = claims.sub || claims["cognito:username"];
  const username = claims["cognito:username"] || claims.preferred_username || "";
  return { userId: sub || "unknown", username };
}

function json(status, body) {
  return { statusCode: status, headers: { "Content-Type": "application/json", "Cache-Control": "no-store" }, body: JSON.stringify(body) };
}

async function cacheGet(key) {
  if (!CACHE_TABLE) return null;
  try {
    const r = await ddb.send(new GetCommand({ TableName: CACHE_TABLE, Key: { cache_key: key } }));
    if (r.Item && r.Item.expires_at > Math.floor(Date.now() / 1000)) return r.Item.value;
  } catch (e) { console.warn("CVE cache get:", e.message); }
  return null;
}

async function cachePut(key, value, ttlSec) {
  if (!CACHE_TABLE) return;
  try {
    await ddb.send(new PutCommand({
      TableName: CACHE_TABLE,
      Item: { cache_key: key, value, expires_at: Math.floor(Date.now() / 1000) + ttlSec },
    }));
  } catch (e) { console.warn("CVE cache put:", e.message); }
}

function getDateRange(period) {
  const now = new Date();
  let start, end;
  if (period === "this_month") {
    start = new Date(now.getFullYear(), now.getMonth(), 1);
    end = now;
  } else if (period === "last_month") {
    start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    end = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
  } else {
    // last_90
    end = now;
    start = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
  }
  return {
    start: start.toISOString().replace(/\.\d{3}Z$/, ".000Z"),
    end: end.toISOString().replace(/\.\d{3}Z$/, ".000Z"),
  };
}

// ------------------------------------------------------------------------------
// NVD 2.0 — parse raw cve to our shape
// ------------------------------------------------------------------------------

function nvdFromCve(cve) {
  if (!cve) return null;
  const meta = cve.cveMetadata || {};
  const enDesc = (cve.descriptions || []).find((d) => (d.lang || "").toLowerCase() === "en");
  const desc = enDesc?.value || (cve.descriptions || [])[0]?.value || "";
  const metrics = cve.metrics || {};
  const cvss31 = (metrics.cvssMetricV31 || [])[0]?.cvssData;
  const cvss30 = (metrics.cvssMetricV30 || [])[0]?.cvssData;
  const cvss2 = (metrics.cvssMetricV2 || [])[0]?.cvssData;
  const score = cvss31?.baseScore ?? cvss30?.baseScore ?? cvss2?.baseScore ?? 0;
  return {
    id: meta.cveId || null,
    description: desc,
    published: meta.datePublished || null,
    updated: meta.dateUpdated || meta.datePublished || null,
    references: (cve.references || []).map((r) => r.url).filter(Boolean),
    cvss: {
      v3_1: cvss31 ? { score: cvss31.baseScore, severity: cvss31.baseSeverity, vector: cvss31.vectorString } : null,
      v3_0: cvss30 ? { score: cvss30.baseScore, severity: cvss30.baseSeverity, vector: cvss30.vectorString } : null,
      v2: cvss2 ? { score: cvss2.baseScore, severity: cvss2.baseSeverity, vector: cvss2.vectorString } : null,
    },
    cwe: (cve.weaknesses || [])[0]?.description?.[0]?.value || null,
    configurations: (cve.configurations || []).length,
    _score: score,
  };
}

// ------------------------------------------------------------------------------
// NVD — fetch by CVE ID
// ------------------------------------------------------------------------------

async function fetchNvd(cveId) {
  const norm = String(cveId || "").trim().toUpperCase();
  if (!/^CVE-\d{4}-\d{4,}$/.test(norm)) return null;
  const url = new URL("https://services.nvd.nist.gov/rest/json/cves/2.0");
  url.searchParams.set("cveId", norm);
  if (NVD_API_KEY) url.searchParams.set("apiKey", NVD_API_KEY);

  const res = await fetch(url.toString(), { headers: { Accept: "application/json" } });
  if (!res.ok) return null;
  const data = await res.json();
  const cve = (data?.vulnerabilities || [])[0]?.cve;
  return nvdFromCve(cve);
}

// ------------------------------------------------------------------------------
// NVD — search (pub date, severity, keyword); returns array of nvd-shaped items
// ------------------------------------------------------------------------------

async function fetchNvdSearch(opts) {
  const { pubStart, pubEnd, severity, keyword, resultsPerPage = 50 } = opts;
  const url = new URL("https://services.nvd.nist.gov/rest/json/cves/2.0");
  url.searchParams.set("pubStartDate", pubStart);
  url.searchParams.set("pubEndDate", pubEnd);
  url.searchParams.set("resultsPerPage", String(Math.min(200, resultsPerPage)));
  url.searchParams.set("startIndex", "0");
  if (severity && severity !== "BOTH") url.searchParams.set("cvssV3Severity", severity);
  if (keyword) url.searchParams.set("keywordSearch", keyword);
  if (NVD_API_KEY) url.searchParams.set("apiKey", NVD_API_KEY);

  const res = await fetch(url.toString(), { headers: { Accept: "application/json" } });
  if (!res.ok) {
    const txt = await res.text();
    console.error("NVD search failed:", res.status, url.searchParams.toString(), txt.slice(0, 500));
    return { items: [], nvdStatus: res.status };
  }
  const data = await res.json();
  const vulns = data?.vulnerabilities || [];
  const items = vulns.map((v) => nvdFromCve(v.cve)).filter(Boolean);
  return { items, nvdStatus: null };
}

// ------------------------------------------------------------------------------
// OSV
// ------------------------------------------------------------------------------

async function fetchOsvByCve(cveId) {
  const norm = String(cveId || "").trim();
  if (!norm) return null;
  try {
    const res = await fetch(`https://api.osv.dev/v1/vulns/${encodeURIComponent(norm)}`, { headers: { Accept: "application/json" } });
    if (!res.ok) return null;
    const v = await res.json();
    return {
      id: v.id || null,
      summary: v.summary || v.details || null,
      affected: (v.affected || []).map((a) => ({ package: a.package?.name, ecosystem: a.package?.ecosystem, ranges: (a.ranges || []).length })),
      references: (v.references || []).map((r) => r.url).filter(Boolean),
      severity: (v.severity || []).map((s) => ({ type: s.type, score: s.score })).filter((s) => s.score),
    };
  } catch (e) { return null; }
}

async function fetchOsvByPackage(ecosystem, pkg, version) {
  if (!ecosystem || !pkg) return null;
  const body = { package: { name: String(pkg).trim(), ecosystem: String(ecosystem).trim() } };
  if (version) body.version = String(version).trim();
  try {
    const res = await fetch("https://api.osv.dev/v1/query", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) return null;
    const data = await res.json();
    const vulns = data?.vulns || [];
    return vulns.slice(0, 20).map((v) => ({
      id: v.id,
      summary: (v.summary || v.details || "").slice(0, 500),
      aliases: v.aliases || [],
      severity: (v.severity || []).map((s) => ({ type: s.type, score: s.score })).filter((s) => s.score),
    }));
  } catch (e) { return null; }
}

// ------------------------------------------------------------------------------
// AI ANALYSIS (OpenAI)
// ------------------------------------------------------------------------------

const CVE_AI_PROMPT = `You are a senior vulnerability analyst. Given CVE/vulnerability data, produce a SHORT "should I be worried?" assessment.

Respond ONLY with valid JSON in this shape:
{
  "verdict": "high" | "medium" | "low" | "informational",
  "one_liner": "Single sentence: should they be worried?",
  "factors": ["factor 1", "factor 2"],
  "recommendation": "1-2 sentences on what to do (patch, mitigate, monitor, or ignore)."
}

Be concise. Prefer "high" for Critical/High CVSS or RCE, default-insecure, or actively exploited. "low" for older, non-default, or requiring physical/local access.`;

async function aiAnalyzeCve(cveId, nvd, osv, pkgContext) {
  if (!OPENAI_API_KEY) return null;
  const ctx = [
    nvd ? `NVD: ${nvd.description?.slice(0, 800) || "No description"}. CVSS: ${JSON.stringify(nvd.cvss || {})}.` : "",
    osv ? `OSV: ${osv.summary?.slice(0, 400) || "No summary"}. Affected: ${JSON.stringify(osv.affected || [])}.` : "",
    pkgContext ? `User context: ${pkgContext}` : "",
  ].filter(Boolean).join("\n");

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: OPENAI_MODEL,
      messages: [
        { role: "system", content: CVE_AI_PROMPT },
        { role: "user", content: `CVE: ${cveId}\n\n${ctx || "No NVD/OSV data."}` },
      ],
      temperature: 0.3,
      max_tokens: 600,
      response_format: { type: "json_object" },
    }),
  });
  if (!res.ok) return null;
  const data = await res.json();
  const text = data?.choices?.[0]?.message?.content;
  if (!text) return null;
  try { return JSON.parse(text); } catch { return { one_liner: text, verdict: "unknown", factors: [], recommendation: "" }; }
}

// ------------------------------------------------------------------------------
// HANDLER
// ------------------------------------------------------------------------------

exports.handler = async (event) => {
  try {
    const { userId } = getAuth(event);
    if (userId === "unknown") return json(401, { error: "Authentication required" });

    const body = (event.body && typeof event.body === "string") ? JSON.parse(event.body) : (event.body || {});
    const mode = String(body.mode || "cve").toLowerCase();
    const analyze = !!body.analyze;

    // --- MODE: top (browse top 30 by period/severity/category) ---
    if (mode === "top") {
      const period = String(body.period || "last_month").toLowerCase();
      const severity = String(body.severity || "CRITICAL").toUpperCase();
      const category = String(body.category || "all").toLowerCase().trim();
      const keyword = (CATEGORY_KEYWORDS[category] !== undefined) ? CATEGORY_KEYWORDS[category] : (category && category !== "all" ? category : null);

      const cacheKey = `cve:top:${period}:${severity}:${category || "all"}`;
      const cached = await cacheGet(cacheKey);
      if (cached) return json(200, { ...cached, cached: true });

      const { start: pubStart, end: pubEnd } = getDateRange(period);
      const resultsPerPage = 50;

      let items = [];
      let nvdError = null;
      if (severity === "BOTH") {
        const crit = await fetchNvdSearch({ pubStart, pubEnd, severity: "CRITICAL", keyword, resultsPerPage });
        nvdError = crit.nvdStatus || nvdError;
        await sleep(NVD_RATE_DELAY_MS);
        const high = await fetchNvdSearch({ pubStart, pubEnd, severity: "HIGH", keyword, resultsPerPage });
        nvdError = high.nvdStatus || nvdError;
        items = [...(crit.items || []), ...(high.items || [])];
      } else {
        const out = await fetchNvdSearch({ pubStart, pubEnd, severity: severity === "HIGH" ? "HIGH" : "CRITICAL", keyword, resultsPerPage });
        nvdError = out.nvdStatus;
        items = out.items || [];
      }

      // drop items without id, _score from output, sort desc, take 30
      items = items
        .filter((x) => x && x.id)
        .sort((a, b) => (b._score || 0) - (a._score || 0))
        .slice(0, 30)
        .map(({ _score, ...r }) => r);

      const result = { mode: "top", items, period, severity, category: category || "all", total: items.length };
      if (nvdError) {
        result.apiError = `NVD API returned ${nvdError}. Without an API key, NVD allows 5 requests/30s — you may have hit the limit. Add NVD_API_KEY in Terraform for higher limits.`;
      }
      // do not cache empty results (avoids caching 429/403 responses)
      if (items.length > 0) await cachePut(cacheKey, result, 3600);
      return json(200, { ...result, cached: false });
    }

    if (mode === "cve") {
      const cveId = String(body.cveId || "").trim();
      if (!cveId) return json(400, { error: "cveId is required for mode cve" });

      const cacheKey = `cve:${cveId}:${analyze ? "1" : "0"}`;
      const cached = await cacheGet(cacheKey);
      if (cached) return json(200, { ...cached, cached: true });

      const [nvd, osv] = await Promise.all([fetchNvd(cveId), fetchOsvByCve(cveId)]);
      if (!nvd && !osv) return json(404, { error: "CVE not found in NVD or OSV", cveId });

      let ai_analysis = null;
      if (analyze) {
        const aiKey = `cve:ai:${cveId}`;
        ai_analysis = await cacheGet(aiKey);
        if (!ai_analysis) {
          ai_analysis = await aiAnalyzeCve(cveId, nvd, osv, body.context || null);
          if (ai_analysis) await cachePut(aiKey, ai_analysis, 86400);
        }
      }

      const result = { mode: "cve", cveId, nvd, osv, ai_analysis };
      await cachePut(cacheKey, result, 3600);
      return json(200, { ...result, cached: false });
    }

    if (mode === "package") {
      const ecosystem = String(body.ecosystem || "").trim();
      const pkg = String(body.package || "").trim();
      const version = (body.version && String(body.version).trim()) || null;
      if (!ecosystem || !pkg) return json(400, { error: "ecosystem and package are required for mode package" });

      const cacheKey = `cve:pkg:${ecosystem}:${pkg}:${version || ""}:${analyze ? "1" : "0"}`;
      const cached = await cacheGet(cacheKey);
      if (cached) return json(200, { ...cached, cached: true });

      const osv = await fetchOsvByPackage(ecosystem, pkg, version);
      const vulns = Array.isArray(osv) ? osv : (osv ? [osv] : []);
      const firstCve = vulns[0]?.id || vulns[0]?.aliases?.[0];
      let nvd = null;
      if (firstCve && /^CVE-/.test(firstCve)) nvd = await fetchNvd(firstCve);

      let ai_analysis = null;
      if (analyze && (vulns.length > 0 || nvd)) {
        const ctx = `${ecosystem}/${pkg}${version ? "@" + version : ""}`;
        ai_analysis = await aiAnalyzeCve(firstCve || pkg, nvd, vulns[0] || null, ctx);
      }

      const result = { mode: "package", ecosystem, package: pkg, version, vulns, nvd: nvd ? [nvd] : [], ai_analysis };
      await cachePut(cacheKey, result, 1800);
      return json(200, { ...result, cached: false });
    }

    return json(400, { error: "mode must be 'cve', 'package', or 'top'" });
  } catch (e) {
    console.error("CVE lookup error:", e);
    return json(500, { error: e.message || "CVE lookup failed" });
  }
};
